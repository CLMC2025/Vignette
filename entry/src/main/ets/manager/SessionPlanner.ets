// =====================================================
// SessionPlanner.ets - å­¦ä¹ ä¼šè¯ä»»åŠ¡ç¼–æ’å™¨
// å°†çº¿æ€§åˆ·è¯å‡çº§ä¸ºå¤šä»»åŠ¡æ··ç¼–çš„æ™ºèƒ½å­¦ä¹ ç³»ç»Ÿ
// =====================================================

import { WordItem, WordStatus, Rating } from '../model/WordModel';

/**
 * ä»»åŠ¡ç±»å‹æšä¸¾
 */
export enum TaskType {
  STORY = 'STORY'           // æƒ…å¢ƒæ•…äº‹ï¼ˆç‚¹å‡»è¯é‡Šä¹‰ï¼‰
}

/**
 * é”™å› ç±»å‹æšä¸¾
 */
export enum ErrorType {
  MEANING = 'MEANING',       // é‡Šä¹‰é”™è¯¯
  USAGE = 'USAGE',           // ç”¨æ³•é”™è¯¯
  SPELLING = 'SPELLING',       // æ‹¼å†™é”™è¯¯
  PRONUNCIATION = 'PRONUNCIATION', // å‘éŸ³é”™è¯¯
  CONFUSION = 'CONFUSION'     // æ··æ·†é”™è¯¯ï¼ˆå½¢è¿‘è¯/éŸ³è¿‘è¯ï¼‰
}

/**
 * ä»»åŠ¡éš¾åº¦çº§åˆ«
 */
export enum TaskDifficulty {
  EASY = 1,
  MEDIUM = 2,
  HARD = 3
}

/**
 * å­¦ä¹ ä»»åŠ¡é¡¹
 */
export class TaskItem {
  id: string;
  type: TaskType;
  word: WordItem;
  difficulty: TaskDifficulty;
  content: string;              // ä»»åŠ¡å†…å®¹ï¼ˆæ•…äº‹/å¥å­/é—®é¢˜ç­‰ï¼‰
  options?: string[];            // é€‰æ‹©é¢˜é€‰é¡¹
  correctAnswer?: string;        // æ­£ç¡®ç­”æ¡ˆ
  userAnswer?: string;          // ç”¨æˆ·ç­”æ¡ˆ
  isCorrect?: boolean;          // æ˜¯å¦æ­£ç¡®
  errorTag?: ErrorType;         // é”™å› æ ‡ç­¾
  reflection?: string;           // ç”¨æˆ·åæ€ï¼ˆé”™å› å¤ç›˜ï¼‰
  isReinforcement: boolean;     // æ˜¯å¦ä¸ºå¼ºåŒ–ä»»åŠ¡ï¼ˆé—å¿˜åæ’å…¥ï¼‰
  priority: number;             // ä¼˜å…ˆçº§ï¼ˆ0=æœ€é«˜ï¼‰
  estimatedTime: number;        // é¢„ä¼°æ—¶é—´ï¼ˆç§’ï¼‰
  preferredOffset?: number;

  constructor(
    id: string,
    type: TaskType,
    word: WordItem,
    difficulty: TaskDifficulty = TaskDifficulty.MEDIUM,
    content: string = '',
    isReinforcement: boolean = false,
    priority: number = 0,
    estimatedTime: number = 20
  ) {
    this.id = id;
    this.type = type;
    this.word = word;
    this.difficulty = difficulty;
    this.content = content;
    this.isReinforcement = isReinforcement;
    this.priority = priority;
    this.estimatedTime = estimatedTime;
  }

  /**
   * è·å–ä»»åŠ¡ç±»å‹çš„ä¸­æ–‡åç§°
   */
  getTypeName(): string {
    return 'æƒ…å¢ƒæ•…äº‹';
  }

  /**
   * è·å–ä»»åŠ¡ç±»å‹å›¾æ ‡
   */
  getTypeIcon(): string {
    return 'ğŸ“–';
  }

  /**
   * æ£€æŸ¥ä»»åŠ¡æ˜¯å¦å®Œæˆ
   */
  isCompleted(): boolean {
    return this.userAnswer !== undefined;
  }

  /**
   * è·å–ä»»åŠ¡çŠ¶æ€æ–‡æœ¬
   */
  getStatusText(): string {
    if (!this.isCompleted()) {
      return 'å¾…å®Œæˆ';
    }
    if (this.isCorrect === undefined) {
      return 'å¾…è¯„ä»·';
    }
    return this.isCorrect ? 'æ­£ç¡®' : 'é”™è¯¯';
  }
}

/**
 * ä¼šè¯ç¼–æ’é…ç½®
 */
export class SessionConfig {
  storyRatio: number;           // æ•…äº‹ä»»åŠ¡æ¯”ä¾‹ï¼ˆ0-1ï¼‰
  clozeRatio: number;           // å¡«ç©ºä»»åŠ¡æ¯”ä¾‹
  choiceRatio: number;           // é€‰æ‹©é¢˜æ¯”ä¾‹
  collocationRatio: number;      // æ­é…ä»»åŠ¡æ¯”ä¾‹
  pronunciationRatio: number;   // å‘éŸ³ä»»åŠ¡æ¯”ä¾‹
  maxTasksPerWord: number;      // æ¯ä¸ªè¯æœ€å¤šä»»åŠ¡æ•°
  reinforcementCount: number;   // é—å¿˜åæ’å…¥å¼ºåŒ–ä»»åŠ¡æ•°

  constructor(
    storyRatio: number = 0.4,
    clozeRatio: number = 0.25,
    choiceRatio: number = 0.15,
    collocationRatio: number = 0.15,
    pronunciationRatio: number = 0.05,
    maxTasksPerWord: number = 3,
    reinforcementCount: number = 2
  ) {
    this.storyRatio = storyRatio;
    this.clozeRatio = clozeRatio;
    this.choiceRatio = choiceRatio;
    this.collocationRatio = collocationRatio;
    this.pronunciationRatio = pronunciationRatio;
    this.maxTasksPerWord = maxTasksPerWord;
    this.reinforcementCount = reinforcementCount;
  }

  /**
   * éªŒè¯é…ç½®æ˜¯å¦æœ‰æ•ˆ
   */
  isValid(): boolean {
    const total = this.storyRatio + this.clozeRatio + this.choiceRatio +
                  this.collocationRatio + this.pronunciationRatio;
    return Math.abs(total - 1.0) < 0.01;
  }
}

/**
 * å­¦ä¹ ä¼šè¯ç¼–æ’å™¨
 */
export class SessionPlanner {
  private static instance: SessionPlanner | null = null;
  private config: SessionConfig;
  private taskIdCounter: number = 0;

  private constructor() {
    this.config = new SessionConfig();
  }

  /**
   * è·å–å•ä¾‹å®ä¾‹
   */
  static getInstance(): SessionPlanner {
    if (SessionPlanner.instance === null) {
      SessionPlanner.instance = new SessionPlanner();
    }
    return SessionPlanner.instance;
  }

  /**
   * è®¾ç½®ç¼–æ’é…ç½®
   */
  setConfig(config: SessionConfig): void {
    if (config.isValid()) {
      this.config = config;
    } else {
      console.warn('[SessionPlanner] Invalid config, using default');
    }
  }

  /**
   * è·å–å½“å‰é…ç½®
   */
  getConfig(): SessionConfig {
    return this.config;
  }

  /**
   * ç”Ÿæˆä»»åŠ¡ID
   */
  private generateTaskId(): string {
    return `task_${Date.now()}_${this.taskIdCounter++}`;
  }

  /**
   * ç”ŸæˆåŸºç¡€ä»»åŠ¡ï¼ˆV1: ä»…æƒ…å¢ƒæ•…äº‹ï¼‰
   */
  private generateBaseTasks(word: WordItem): TaskItem[] {
    const tasks: TaskItem[] = [];
    const isNewWord = word.status === WordStatus.NEW;

    // V1: ä»…ç”Ÿæˆæ•…äº‹ä»»åŠ¡
    tasks.push(new TaskItem(
      this.generateTaskId(),
      TaskType.STORY,
      word,
      isNewWord ? TaskDifficulty.EASY : TaskDifficulty.MEDIUM,
      '',
      false,
      isNewWord ? 1 : 0,
      30
    ));

    return tasks;
  }

  /**
   * ç”Ÿæˆå¼ºåŒ–ä»»åŠ¡ï¼ˆé—å¿˜åæ’å…¥ï¼‰
   */
  generateReinforcementTasks(word: WordItem, rating: Rating, allowOnPass: boolean = false): TaskItem[] {
    const tasks: TaskItem[] = [];

    // åªæœ‰ AGAIN æˆ– HARD æ‰ç”Ÿæˆå¼ºåŒ–ä»»åŠ¡
    if (!allowOnPass && (rating === Rating.GOOD || rating === Rating.EASY)) {
      return tasks;
    }

    // V1: ä»…ä¿ç•™è¯­å¢ƒé˜…è¯»å¼ºåŒ–ä»»åŠ¡
    tasks.push(new TaskItem(
      this.generateTaskId(),
      TaskType.STORY,
      word,
      TaskDifficulty.EASY,
      '',
      true,
      0,
      30
    ));

    // é™åˆ¶å¼ºåŒ–ä»»åŠ¡æ•°é‡
    return tasks.slice(0, this.config.reinforcementCount);
  }



  /**
   * ä¸ºå•è¯åˆ—è¡¨ç¼–æ’å®Œæ•´ä¼šè¯
   */
  planSession(words: WordItem[]): TaskItem[] {
    const allTasks: TaskItem[] = [];

    for (const word of words) {
      const wordTasks = this.generateBaseTasks(word);
      allTasks.push(...wordTasks);
    }

    // æŒ‰ä¼˜å…ˆçº§æ’åºï¼ˆå¼ºåŒ–ä»»åŠ¡ä¼˜å…ˆï¼‰
    allTasks.sort((a: TaskItem, b: TaskItem): number => {
      if (a.isReinforcement && !b.isReinforcement) return -1;
      if (!a.isReinforcement && b.isReinforcement) return 1;
      return a.priority - b.priority;
    });

    return allTasks;
  }

  /**
   * V1 å¾®è¯­å¢ƒå­¦ä¹ ä¼šè¯ï¼ˆä»… STORYï¼‰
   */
  planMicroContextSession(words: WordItem[]): TaskItem[] {
    const tasks: TaskItem[] = [];
    for (const word of words) {
      tasks.push(new TaskItem(
        this.generateTaskId(),
        TaskType.STORY,
        word,
        this.getRecommendedDifficulty(word),
        '',
        false,
        0,
        30
      ));
    }
    return tasks;
  }

  /**
   * è®¡ç®—ä¼šè¯æ€»é¢„ä¼°æ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰
   */
  estimateSessionTime(tasks: TaskItem[]): number {
    const totalSeconds = tasks.reduce((sum: number, task: TaskItem): number => {
      return sum + task.estimatedTime;
    }, 0);
    return Math.round(totalSeconds / 60);
  }

  /**
   * è·å–ä»»åŠ¡ç±»å‹åˆ†å¸ƒç»Ÿè®¡
   */
  getTaskDistribution(tasks: TaskItem[]): Map<TaskType, number> {
    const distribution = new Map<TaskType, number>();

    for (const task of tasks) {
      const count = distribution.get(task.type) ?? 0;
      distribution.set(task.type, count + 1);
    }

    return distribution;
  }

  /**
   * æ£€æŸ¥æ˜¯å¦éœ€è¦ä¸ºå•è¯ç”Ÿæˆå¼ºåŒ–ä»»åŠ¡
   */
  shouldReinforce(word: WordItem, rating: Rating): boolean {
    return rating === Rating.AGAIN || rating === Rating.HARD;
  }

  /**
   * è·å–æ¨èçš„ä»»åŠ¡éš¾åº¦
   */
  getRecommendedDifficulty(word: WordItem): TaskDifficulty {
    // æ ¹æ®å•è¯çŠ¶æ€æ¨èéš¾åº¦
    if (word.status === WordStatus.NEW) {
      return TaskDifficulty.EASY;
    } else if (word.status === WordStatus.LEARNING) {
      return TaskDifficulty.MEDIUM;
    } else {
      return TaskDifficulty.HARD;
    }
  }

  /**
   * ç”Ÿæˆä¼šè¯æ‘˜è¦
   */
  generateSessionSummary(tasks: TaskItem[]): string {
    const totalTasks = tasks.length;
    const reinforcementTasks = tasks.filter((t: TaskItem): boolean => t.isReinforcement).length;
    const estimatedTime = this.estimateSessionTime(tasks);
    const distribution = this.getTaskDistribution(tasks);

    let summary = `ä¼šè¯åŒ…å« ${totalTasks} ä¸ªä»»åŠ¡ï¼Œé¢„è®¡è€—æ—¶ ${estimatedTime} åˆ†é’Ÿ\n`;
    summary += `å¼ºåŒ–ä»»åŠ¡: ${reinforcementTasks} ä¸ª\n`;
    summary += 'ä»»åŠ¡åˆ†å¸ƒ:\n';

    distribution.forEach((count: number, type: string) => {
      const taskItem = new TaskItem('', type as TaskType, new WordItem());
      summary += `  ${taskItem.getTypeName()}: ${count} ä¸ª\n`;
    });

    return summary;
  }
}
