// =====================================================
// DataExportImport.ets - æ•°æ®å¯¼å‡ºå’Œå¯¼å…¥åŠŸèƒ½
// æ”¯æŒJSONæ ¼å¼å¯¼å‡ºã€æ•°æ®å‹ç¼©å’Œå†²çªè§£å†³
// =====================================================

import { VersionControl } from './VersionControl';
import { WordItem } from '../model/WordModel';
import { util } from '@kit.ArkTS';
import taskpool from '@ohos.taskpool';
import { stringifyJson } from './webdav/WebDavCryptoTask';

/**
 * å¯¼å‡ºçš„å•è¯æ•°æ®ï¼ˆæ™ºèƒ½åŒæ­¥é‡Šä¹‰ï¼šä»…åŒæ­¥é builtin æ¥æºï¼‰
 */
export class ExportedWord {
  id: number;
  word: string;
  status: string;
  fsrsState: string;
  history: string;
  definition: string;
  definitionSource: string;
  dueDate: number;
  createdAt: number;
  updatedAt: number;
  bookId: string;
  tags: string[];
  lapseCount: number;
  leechLevel: number;
  errorTags: string[];
  suspendUntil: number;

  constructor(word: WordItem) {
    this.id = word.id;
    this.word = word.word;
    this.status = word.status;
    this.fsrsState = word.fsrsState.toJSON();
    this.history = word.history.toJSON();
    this.definitionSource = word.definition.source;
    if (word.definition.source === 'ai' || word.definition.source === 'local') {
      this.definition = word.definition.toJSON();
    } else {
      this.definition = '';
    }
    this.dueDate = word.dueDate;
    this.createdAt = word.createdAt;
    this.updatedAt = word.updatedAt;
    this.bookId = word.bookId;
    this.tags = word.tags;
    this.lapseCount = word.lapseCount;
    this.leechLevel = word.leechLevel;
    this.errorTags = word.errorTags;
    this.suspendUntil = word.suspendUntil;
  }
}

/**
 * å¯¼å‡ºçš„å®šä¹‰æ•°æ®
 */
export class ExportedDefinition {
  word: string;
  definition: string;
  source: string;
  createdAt: number;

  constructor(word: string, definition: string, source: string, createdAt: number) {
    this.word = word;
    this.definition = definition;
    this.source = source;
    this.createdAt = createdAt;
  }
}

/**
 * å¯¼å‡ºçš„ç”¨æˆ·è¯ä¹¦æ•°æ®
 */
export class ExportedUserBook {
  id: string;
  name: string;
  description: string;
  category: string;
  difficulty: string;
  coverColor: string;
  icon: string;
  createdAt: number;
  updatedAt: number;

  constructor(book: ExportedUserBookInput) {
    this.id = book.id;
    this.name = book.name;
    this.description = book.description || '';
    this.category = book.category || 'å…¶ä»–';
    this.difficulty = book.difficulty || 'åˆçº§';
    this.coverColor = book.coverColor || '["#a8edea", "#fed6e3"]';
    this.icon = book.icon || 'ğŸ““';
    this.createdAt = book.createdAt;
    this.updatedAt = book.updatedAt;
  }
}

/**
 * å¯¼å‡ºçš„ç”¨æˆ·è¯ä¹¦è¾“å…¥æ¥å£
 */
export interface ExportedUserBookInput {
  id: string;
  name: string;
  description: string;
  category?: string;
  difficulty?: string;
  coverColor?: string;
  icon?: string;
  createdAt: number;
  updatedAt: number;
}

/**
 * å¯¼å‡ºæ•°æ®ç»“æ„
 */
/**
 * JSONå¯¼å‡ºæ•°æ®æ¥å£
 */
export interface ExportDataJSON {
  version?: string;
  timestamp?: number;
  appVersion?: string;
  words?: ExportedWord[];
  definitions?: ExportedDefinition[];
  userBooks?: ExportedUserBook[];
  versionControl?: string;
  fsrsParamsJson?: string;
}

interface GeneratedObjectLiteralInterface_1 {
  version: string;
  timestamp: number;
  appVersion: string;
  words: ExportedWord[];
  definitions: ExportedDefinition[];
  userBooks: ExportedUserBook[];
  versionControl: string;
  fsrsParamsJson: string;
}

export class ExportData {
  version: string;
  timestamp: number;
  appVersion: string;
  words: ExportedWord[];
  definitions: ExportedDefinition[];
  userBooks: ExportedUserBook[];
  versionControl: string;
  fsrsParamsJson: string;

  constructor(
    version: string = '1.0',
    timestamp: number = Date.now(),
    appVersion: string = '1.0.0'
  ) {
    this.version = version;
    this.timestamp = timestamp;
    this.appVersion = appVersion;
    this.words = [];
    this.definitions = [];
    this.userBooks = [];
    this.versionControl = '';
    this.fsrsParamsJson = '';
  }

  /**
   * åºåˆ—åŒ–ä¸ºJSON
   */
  toJSON(): string {
    const obj: GeneratedObjectLiteralInterface_1 = {
      version: this.version,
      timestamp: this.timestamp,
      appVersion: this.appVersion,
      words: this.words,
      definitions: this.definitions,
      userBooks: this.userBooks,
      versionControl: this.versionControl,
      fsrsParamsJson: this.fsrsParamsJson
    };
    return JSON.stringify(obj);
  }

  /**
   * ä»JSONååºåˆ—åŒ–
   */
  static fromJSON(json: string): ExportData {
    try {
      const obj = JSON.parse(json) as ExportDataJSON;
      const data = new ExportData();

      if (obj.version !== undefined) {
        data.version = obj.version;
      }
      if (obj.timestamp !== undefined) {
        data.timestamp = obj.timestamp;
      }
      if (obj.appVersion !== undefined) {
        data.appVersion = obj.appVersion;
      }
      if (obj.words !== undefined) {
        data.words = obj.words;
      }
      if (obj.definitions !== undefined) {
        data.definitions = obj.definitions;
      }
      if (obj.userBooks !== undefined) {
        data.userBooks = obj.userBooks;
      }
      if (obj.versionControl !== undefined) {
        data.versionControl = obj.versionControl;
      }
      if (obj.fsrsParamsJson !== undefined) {
        data.fsrsParamsJson = obj.fsrsParamsJson;
      }

      return data;
    } catch (e) {
      return new ExportData();
    }
  }
}

/**
 * åŒæ­¥ç»“æœ
 */
export class SyncResult {
  imported: number;
  updated: number;
  conflicts: number;
  skipped: number;
  errors: string[];

  constructor() {
    this.imported = 0;
    this.updated = 0;
    this.conflicts = 0;
    this.skipped = 0;
    this.errors = [];
  }

  /**
   * æ·»åŠ é”™è¯¯ä¿¡æ¯
   */
  addError(error: string): void {
    this.errors.push(error);
  }

  /**
   * æ˜¯å¦æœ‰é”™è¯¯
   */
  hasErrors(): boolean {
    return this.errors.length > 0;
  }

  /**
   * è·å–æ‘˜è¦ä¿¡æ¯
   */
  getSummary(): string {
    return `å¯¼å…¥: ${this.imported}, æ›´æ–°: ${this.updated}, å†²çª: ${this.conflicts}, è·³è¿‡: ${this.skipped}`;
  }
}

export interface ImportResult {
  data: ExportData;
  result: SyncResult;
}

/**
 * æ•°æ®å¯¼å‡ºå¯¼å…¥ç®¡ç†å™¨
 */
export class DataExportImport {
  /**
   * å¯¼å‡ºæ•°æ®ä¸ºJSONå­—ç¬¦ä¸²
   */
  exportToJSON(
    words: WordItem[],
    definitions: ExportedDefinition[],
    versionControl: VersionControl,
    fsrsParamsJson: string = '',
    userBooks: ExportedUserBook[] = []
  ): string {
    const exportedWords: ExportedWord[] = [];
    const batchSize = 100;
    
    for (let i = 0; i < words.length; i += batchSize) {
      const batch = words.slice(i, i + batchSize);
      for (const word of batch) {
        exportedWords.push(new ExportedWord(word));
      }
    }

    const obj: GeneratedObjectLiteralInterface_1 = {
      version: '1.0',
      timestamp: Date.now(),
      appVersion: '1.0.0',
      words: exportedWords,
      definitions: definitions,
      userBooks: userBooks,
      versionControl: versionControl.toJSON(),
      fsrsParamsJson: fsrsParamsJson
    };

    return JSON.stringify(obj);
  }

  /**
   * å¯¼å‡ºæ•°æ®ä¸ºJSONå­—ç¬¦ä¸²ï¼ˆå¼‚æ­¥ç‰ˆæœ¬ï¼Œä½¿ç”¨taskpoolé¿å…ä¸»çº¿ç¨‹é˜»å¡ï¼‰
   */
  async exportToJSONAsync(
    words: WordItem[],
    definitions: ExportedDefinition[],
    versionControl: VersionControl,
    fsrsParamsJson: string = '',
    userBooks: ExportedUserBook[] = []
  ): Promise<string> {
    const exportedWords: ExportedWord[] = [];
    const batchSize = 50;
    
    for (let i = 0; i < words.length; i += batchSize) {
      const batch = words.slice(i, i + batchSize);
      for (const word of batch) {
        exportedWords.push(new ExportedWord(word));
      }
      await new Promise<void>((resolve) => setTimeout(resolve, 0));
    }

    const obj: GeneratedObjectLiteralInterface_1 = {
      version: '1.0',
      timestamp: Date.now(),
      appVersion: '1.0.0',
      words: exportedWords,
      definitions: definitions,
      userBooks: userBooks,
      versionControl: versionControl.toJSON(),
      fsrsParamsJson: fsrsParamsJson
    };

    try {
      const task = new taskpool.Task(stringifyJson, obj);
      const result = await taskpool.execute(task) as string;
      return result;
    } catch (e) {
      console.error('[DataExportImport] Taskpool stringify failed, falling back to sync:', e);
      return JSON.stringify(obj);
    }
  }

  /**
   * ä»JSONå­—ç¬¦ä¸²å¯¼å…¥æ•°æ®
   */
  importFromJSON(
    json: string,
    currentVersion: VersionControl
  ): ImportResult {
    const result = new SyncResult();

    try {
      const importData = ExportData.fromJSON(json);

      // éªŒè¯æ•°æ®æ ¼å¼
      if (importData.version === '1.0') {
        return this.processImportV1(importData, currentVersion, result);
      } else {
        result.addError(`ä¸æ”¯æŒçš„æ•°æ®ç‰ˆæœ¬: ${importData.version}`);
        return { data: importData, result };
      }
    } catch (e) {
      const errMsg = e instanceof Error ? e.message : String(e);
      result.addError(`å¯¼å…¥å¤±è´¥: ${errMsg}`);
      return { data: new ExportData(), result };
    }
  }

  /**
   * å¤„ç†V1ç‰ˆæœ¬æ•°æ®å¯¼å…¥
   */
  private processImportV1(
    importData: ExportData,
    currentVersion: VersionControl,
    result: SyncResult
  ): ImportResult {
    const currentVersionInfo = currentVersion.getCurrentVersion();
    const importVersionControl = VersionControl.fromJSON(importData.versionControl);
    const importVersionInfo = importVersionControl.getCurrentVersion();

    // ç‰ˆæœ¬æ¯”è¾ƒ
    const comparison = VersionControl.compareVersions(currentVersionInfo, importVersionInfo);

    if (comparison < 0) {
      // å¯¼å…¥è¾ƒæ–°ç‰ˆæœ¬çš„æ•°æ®
      result.addError('å¯¼å…¥çš„æ•°æ®ç‰ˆæœ¬è¾ƒæ–°ï¼Œå»ºè®®å…ˆæ›´æ–°åº”ç”¨');
      return { data: importData, result };
    } else {
      // å¯¼å…¥åŒç‰ˆæœ¬æˆ–è¾ƒæ—§ç‰ˆæœ¬çš„æ•°æ®ï¼šå…è®¸å¯¼å…¥ï¼Œç”±ä¸Šå±‚æŒ‰è¯æ¡ç²’åº¦åˆå¹¶ï¼ˆupsertï¼‰
      return { data: importData, result };
    }
  }

  /**
   * åˆå¹¶æ—§ç‰ˆæœ¬æ•°æ®
   */
  private mergeOldData(
    importData: ExportData,
    currentVersion: VersionControl,
    result: SyncResult
  ): ImportResult {
    // æ£€æŸ¥å†²çª
    const importVersionControl = VersionControl.fromJSON(importData.versionControl);
    const importVersionInfo = importVersionControl.getCurrentVersion();
    const currentVersionInfo = currentVersion.getCurrentVersion();

    if (currentVersion.hasConflict(importVersionInfo)) {
      // æœ‰å†²çªï¼Œéœ€è¦ç”¨æˆ·é€‰æ‹©
      result.conflicts++;
      result.addError('æ£€æµ‹åˆ°ç‰ˆæœ¬å†²çªï¼Œè¯·æ‰‹åŠ¨è§£å†³');
      return { data: importData, result };
    }

    // æ— å†²çªï¼Œåˆå¹¶æ•°æ®
    for (const word of importData.words) {
      // æ£€æŸ¥å•è¯æ˜¯å¦å·²å­˜åœ¨
      result.skipped++;
    }

    return { data: importData, result };
  }

  /**
   * åˆå¹¶ç›¸åŒç‰ˆæœ¬æ•°æ®
   */
  private mergeSameVersion(
    importData: ExportData,
    currentVersion: VersionControl,
    result: SyncResult
  ): ImportResult {
    const importVersionControl = VersionControl.fromJSON(importData.versionControl);
    const importVersionInfo = importVersionControl.getCurrentVersion();
    const currentVersionInfo = currentVersion.getCurrentVersion();

    // æ¯”è¾ƒæ—¶é—´æˆ³
    if (importVersionInfo.timestamp > currentVersionInfo.timestamp) {
      // å¯¼å…¥çš„æ•°æ®æ›´æ–°ï¼Œä½¿ç”¨å¯¼å…¥æ•°æ®
      result.imported = importData.words.length;
    } else {
      // å½“å‰æ•°æ®æ›´æ–°ï¼Œè·³è¿‡å¯¼å…¥
      result.skipped = importData.words.length;
    }

    return { data: importData, result };
  }

  /**
   * å‹ç¼©æ•°æ®ï¼ˆç®€åŒ–ç‰ˆï¼Œå®é™…å¯ä½¿ç”¨pakoç­‰åº“ï¼‰
   */
  compressData(data: string): string {
    // ç®€åŒ–å®ç°ï¼Œå®é™…åº”ä½¿ç”¨å‹ç¼©åº“
    return data;
  }

  /**
   * è§£å‹æ•°æ®ï¼ˆç®€åŒ–ç‰ˆï¼‰
   */
  decompressData(data: string): string {
    // ç®€åŒ–å®ç°ï¼Œå®é™…åº”ä½¿ç”¨å‹ç¼©åº“
    return data;
  }

  /**
   * éªŒè¯å¯¼å‡ºæ•°æ®
   */
  validateExportData(data: ExportData): boolean {
    // æ£€æŸ¥å¿…è¦å­—æ®µ
    if (data.version === undefined || data.version === '') {
      return false;
    }
    if (data.timestamp === undefined || data.timestamp <= 0) {
      return false;
    }
    if (data.words === undefined || !Array.isArray(data.words)) {
      return false;
    }

    // æ£€æŸ¥å•è¯æ•°æ®
    for (const word of data.words) {
      if (word.word === undefined || word.word === '') {
        return false;
      }
    }

    return true;
  }

  /**
   * ç”Ÿæˆå¯¼å‡ºæ–‡ä»¶å
   */
  generateExportFileName(): string {
    const date = new Date();
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');

    return `vignette_backup_${year}${month}${day}_${hours}${minutes}.json`;
  }

  /**
   * è®¡ç®—æ•°æ®å¤§å°
   */
  calculateDataSize(data: string): string {
    const encoder = new util.TextEncoder();
    const encoded = encoder.encode(data);
    const byteLength = encoded.length;
    const kb = byteLength / 1024;
    const mb = kb / 1024;

    if (mb >= 1) {
      return `${mb.toFixed(2)} MB`;
    } else if (kb >= 1) {
      return `${kb.toFixed(2)} KB`;
    } else {
      return `${byteLength} B`;
    }
  }

  /**
   * å¯¼å‡ºç»Ÿè®¡ä¿¡æ¯
   */
  getExportStats(data: ExportData): string {
    const wordCount = data.words.length;
    const definitionCount = data.definitions.length;
    const dataSize = this.calculateDataSize(data.toJSON());

    return `å•è¯: ${wordCount}, å®šä¹‰: ${definitionCount}, å¤§å°: ${dataSize}`;
  }
}
