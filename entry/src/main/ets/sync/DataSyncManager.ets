// =====================================================
// DataSyncManager.ets - æ•°æ®åŒæ­¥ç®¡ç†å™¨
// ç»Ÿä¸€ç®¡ç†æ•°æ®å¯¼å‡ºã€å¯¼å…¥å’ŒåŒæ­¥æ“ä½œ
// =====================================================

import { VersionControl, ChangeType } from './VersionControl';
import { DataExportImport, ExportData, SyncResult, ExportedWord, ExportedDefinition, ExportedUserBook, ExportedUserBookInput } from './DataExportImport';
import { DBManager, UserWordBook } from '../database/DBManager';
import { WordItem, WordDefinition, WordStatus } from '../model/WordModel';
import { FsrsParamsPack } from '../model/FsrsParamsPack';
import { SettingsStore } from '../utils/SettingsStore';
import { FSRSAlgorithm } from '../algorithm/Algorithm';

/**
 * åŒæ­¥çŠ¶æ€
 */
export enum SyncStatus {
  IDLE = 'IDLE',
  EXPORTING = 'EXPORTING',
  IMPORTING = 'IMPORTING',
  SYNCING = 'SYNCING',
  ERROR = 'ERROR'
}

/**
 * åŒæ­¥é…ç½®
 */
export class SyncConfig {
  autoBackup: boolean;
  backupInterval: number; // æ¯«ç§’
  maxBackupCount: number;
  enableCompression: boolean;

  constructor(
    autoBackup: boolean = true,
    backupInterval: number = 24 * 60 * 60 * 1000, // 24å°æ—¶
    maxBackupCount: number = 5,
    enableCompression: boolean = false
  ) {
    this.autoBackup = autoBackup;
    this.backupInterval = backupInterval;
    this.maxBackupCount = maxBackupCount;
    this.enableCompression = enableCompression;
  }
}

/**
 * å¤‡ä»½ä¿¡æ¯
 */
export class BackupInfo {
  fileName: string;
  timestamp: number;
  size: number;
  wordCount: number;

  constructor(fileName: string, timestamp: number, size: number, wordCount: number) {
    this.fileName = fileName;
    this.timestamp = timestamp;
    this.size = size;
    this.wordCount = wordCount;
  }
}

export class ImportPreview {
  imported: number;
  updated: number;
  total: number;
  errors: string[];
  sampleUpdatedWords: string[];

  constructor() {
    this.imported = 0;
    this.updated = 0;
    this.total = 0;
    this.errors = [];
    this.sampleUpdatedWords = [];
  }
}

/**
 * æ•°æ®åŒæ­¥ç®¡ç†å™¨
 */
export class DataSyncManager {
  private static instance: DataSyncManager | null = null;
  private versionControl: VersionControl;
  private exportImport: DataExportImport;
  private dbManager: DBManager;
  private syncStatus: SyncStatus = SyncStatus.IDLE;
  private syncConfig: SyncConfig;
  private backups: BackupInfo[] = [];

  private constructor() {
    this.versionControl = new VersionControl();
    this.exportImport = new DataExportImport();
    this.dbManager = DBManager.getInstance();
    this.syncConfig = new SyncConfig();
  }

  /**
   * è·å–å•ä¾‹å®ä¾‹
   */
  static getInstance(): DataSyncManager {
    if (DataSyncManager.instance === null) {
      DataSyncManager.instance = new DataSyncManager();
    }
    return DataSyncManager.instance;
  }

  /**
   * è·å–åŒæ­¥çŠ¶æ€
   */
  getSyncStatus(): SyncStatus {
    return this.syncStatus;
  }

  /**
   * è·å–ç‰ˆæœ¬æ§åˆ¶
   */
  getVersionControl(): VersionControl {
    return this.versionControl;
  }

  /**
   * è·å–åŒæ­¥é…ç½®
   */
  getSyncConfig(): SyncConfig {
    return this.syncConfig;
  }

  /**
   * è®¾ç½®åŒæ­¥é…ç½®
   */
  setSyncConfig(config: SyncConfig): void {
    this.syncConfig = config;
  }

  /**
   * å¯¼å‡ºæ•°æ®
   */
  async exportData(): Promise<ExportResult> {
    try {
      const totalWords = await this.dbManager.getWordCount();
      console.info(`[DataSyncManager] Exporting ${totalWords} words in batches`);

      const batchSize = 500;
      const words: WordItem[] = [];

      for (let offset = 0; offset < totalWords; offset += batchSize) {
        const batch = await this.dbManager.getWordsPaged(batchSize, offset);
        words.push(...batch);

        if (offset % 1000 === 0) {
          console.info(`[DataSyncManager] Exported ${words.length}/${totalWords} words`);
        }

        await new Promise<void>((resolve) => setTimeout(resolve, 0));
      }

      await new Promise<void>((resolve) => setTimeout(resolve, 0));

      const userBooks = await this.dbManager.getUserWordBooks();
      const exportedBooks: ExportedUserBook[] = [];
      for (const book of userBooks) {
        const input: ExportedUserBookInput = {
          id: book.id,
          name: book.name,
          description: book.description,
          category: book.category,
          difficulty: book.difficulty,
          coverColor: book.coverColor,
          icon: book.icon,
          createdAt: book.createdAt,
          updatedAt: book.updatedAt
        };
        exportedBooks.push(new ExportedUserBook(input));
      }

      await new Promise<void>((resolve) => setTimeout(resolve, 0));

      const settingsStore = SettingsStore.getInstance();
      const fsrsParams = await settingsStore.getFsrsParams();
      const fsrsParamsJson = fsrsParams !== null ? fsrsParams.toJSON() : '';
      
      // å…ˆé€’å¢ç‰ˆæœ¬å·ï¼Œç¡®ä¿å¯¼å‡ºçš„ JSON åŒ…å«é€’å¢åçš„ç‰ˆæœ¬
      this.versionControl.incrementVersion('æ•°æ®å¯¼å‡º');
      
      const jsonData = await this.exportImport.exportToJSONAsync(words, [], this.versionControl, fsrsParamsJson, exportedBooks);

      this.versionControl.recordChange(
        ChangeType.UPDATE,
        'export',
        0,
        'å¯¼å‡ºæ•°æ®',
        '',
        `${words.length} ä¸ªå•è¯, ${exportedBooks.length} æœ¬è¯ä¹¦`
      );

      return { success: true, data: jsonData, error: '' };
    } catch (e) {
      const errMsg = e instanceof Error ? e.message : String(e);
      console.error('[DataSyncManager] Export failed:', errMsg);
      return { success: false, data: '', error: errMsg };
    }
  }

  /**
   * å¯¼å…¥æ•°æ®
   */
  async importData(jsonData: string): Promise<SyncResult> {
    if (this.syncStatus !== SyncStatus.IDLE) {
      const result = new SyncResult();
      result.addError('åŒæ­¥æ“ä½œæ­£åœ¨è¿›è¡Œä¸­');
      return result;
    }

    this.syncStatus = SyncStatus.IMPORTING;

    try {
      // ä½¿ç”¨å¼‚æ­¥è§£æé¿å…é˜»å¡ä¸»çº¿ç¨‹
      console.info('[DataSyncManager] Starting async JSON import');
      const importResult = await this.exportImport.importFromJSONAsync(jsonData, this.versionControl);
      const data: ExportData = importResult.data;
      const result: SyncResult = importResult.result;

      if (result.hasErrors()) {
        this.syncStatus = SyncStatus.ERROR;
        return result;
      }

      await new Promise<void>((resolve) => setTimeout(resolve, 0));

      if (data.fsrsParamsJson.length > 0) {
        const params = FsrsParamsPack.fromJSON(data.fsrsParamsJson);
        if (params !== null) {
          const settingsStore = SettingsStore.getInstance();
          await settingsStore.saveFsrsParams(params);
          FSRSAlgorithm.getInstance().setParameters(params.w, params.requestRetention, params.maximumInterval);
        }
      }

      // æ‰¹é‡å¤„ç†å•è¯å¯¼å…¥ï¼Œæ¯æ‰¹ 50 æ¡ï¼Œæ¯æ‰¹å yield ç»™ UI çº¿ç¨‹
      const batchSize = 50;
      console.info(`[DataSyncManager] Processing ${data.words.length} words in batches of ${batchSize}`);
      
      for (let i = 0; i < data.words.length; i += batchSize) {
        const batch = data.words.slice(i, i + batchSize);
        
        for (const word of batch) {
          try {
            const wordItem = this.convertToWordItem(word);

            const existing = await this.dbManager.getWordByWord(wordItem.word);
            if (existing === null) {
              await this.dbManager.insertWord(wordItem);
              result.imported++;

              this.versionControl.recordChange(
                ChangeType.INSERT,
                'word',
                wordItem.id,
                `å¯¼å…¥å•è¯: ${wordItem.word}`
              );
            } else {
              wordItem.id = existing.id;
              await this.dbManager.updateWord(wordItem);
              result.updated++;

              this.versionControl.recordChange(
                ChangeType.UPDATE,
                'word',
                wordItem.id,
                `æ›´æ–°å•è¯: ${wordItem.word}`
              );
            }
          } catch (e) {
            const errMsg = e instanceof Error ? e.message : String(e);
            result.addError(`å¯¼å…¥å•è¯å¤±è´¥: ${errMsg}`);
          }
        }
        
        // æ¯æ‰¹å yield ç»™ UI çº¿ç¨‹
        await new Promise<void>((resolve) => setTimeout(resolve, 0));
        
        if ((i + batchSize) % 500 === 0) {
          console.info(`[DataSyncManager] Processed ${i + batchSize}/${data.words.length} words`);
        }
      }

      await new Promise<void>((resolve) => setTimeout(resolve, 0));

      // æ‰¹é‡å¤„ç†å®šä¹‰
      const defBatchSize = 100;
      console.info(`[DataSyncManager] Processing ${data.definitions.length} definitions in batches of ${defBatchSize}`);
      
      for (let i = 0; i < data.definitions.length; i += defBatchSize) {
        const batch = data.definitions.slice(i, i + defBatchSize);
        
        for (const def of batch) {
          try {
            const wordDef = WordDefinition.fromJSON(def.definition);
            await this.dbManager.cacheDefinition(def.word, wordDef);
          } catch (e) {
            const errMsg = e instanceof Error ? e.message : String(e);
            result.addError(`å¯¼å…¥å®šä¹‰å¤±è´¥: ${errMsg}`);
          }
        }
        
        // æ¯æ‰¹å yield ç»™ UI çº¿ç¨‹
        await new Promise<void>((resolve) => setTimeout(resolve, 0));
      }

      const existingUserBooks = await this.dbManager.getUserWordBooks();
      const userBookMap = new Map<string, UserWordBook>();
      for (const existingBook of existingUserBooks) {
        userBookMap.set(existingBook.id, existingBook);
      }

      for (const book of data.userBooks) {
        try {
          const existing = userBookMap.get(book.id);

          if (existing === undefined) {
            const newBookId = await this.dbManager.createUserWordBook(
              book.name,
              book.description,
              book.category || 'å…¶ä»–',
              book.difficulty || 'åˆçº§',
              book.coverColor || '',
              book.icon || 'ğŸ““'
            );
            const createdBook = await this.dbManager.getUserWordBookById(newBookId);
            if (createdBook !== null) {
              userBookMap.set(createdBook.id, createdBook);
            }
            console.info(`[DataSyncManager] Created user book: ${book.name} (${newBookId})`);
          } else if (book.updatedAt > existing.updatedAt) {
            await this.dbManager.updateUserWordBook({
              id: existing.id,
              name: book.name,
              description: book.description,
              wordCount: existing.wordCount,
              isUserCreated: true,
              createdAt: existing.createdAt,
              updatedAt: book.updatedAt,
              category: book.category,
              difficulty: book.difficulty,
              coverColor: book.coverColor,
              icon: book.icon
            });
            const refreshedBook = await this.dbManager.getUserWordBookById(existing.id);
            if (refreshedBook !== null) {
              userBookMap.set(refreshedBook.id, refreshedBook);
            }
            console.info(`[DataSyncManager] Updated user book: ${book.name}`);
          }
        } catch (e) {
          const errMsg = e instanceof Error ? e.message : String(e);
          result.addError(`å¯¼å…¥è¯ä¹¦å¤±è´¥: ${errMsg}`);
        }
      }

      this.versionControl.incrementVersion('æ•°æ®å¯¼å…¥');

      this.syncStatus = SyncStatus.IDLE;
      
      console.info(`[DataSyncManager] Import complete: imported=${result.imported}, updated=${result.updated}`);

      return result;
    } catch (e) {
      this.syncStatus = SyncStatus.ERROR;
      const errMsg = e instanceof Error ? e.message : String(e);
      console.error('[DataSyncManager] Import failed:', errMsg);
      const result = new SyncResult();
      result.addError(`å¯¼å…¥å¤±è´¥: ${errMsg}`);
      return result;
    }
  }

  async previewImport(jsonData: string): Promise<ImportPreview> {
    const preview = new ImportPreview();
    try {
      const importResult = this.exportImport.importFromJSON(jsonData, this.versionControl);
      const data: ExportData = importResult.data;
      const result: SyncResult = importResult.result;
      if (result.hasErrors()) {
        preview.errors = result.errors.slice(0);
        return preview;
      }

      preview.total = data.words.length;
      for (const word of data.words) {
        const w = word.word;
        if (w.length === 0) continue;
        const existing = await this.dbManager.getWordByWord(w);
        if (existing === null) {
          preview.imported++;
        } else {
          preview.updated++;
          if (preview.sampleUpdatedWords.length < 5) {
            preview.sampleUpdatedWords.push(w);
          }
        }
      }
      return preview;
    } catch (e) {
      const msg = e instanceof Error ? e.message : String(e);
      preview.errors.push(msg);
      return preview;
    }
  }

  /**
   * è‡ªåŠ¨å¤‡ä»½
   */
  async autoBackup(): Promise<boolean> {
    if (!this.syncConfig.autoBackup) {
      return false;
    }

    const lastBackup = this.getLastBackupTime();
    const now = Date.now();

    if (now - lastBackup < this.syncConfig.backupInterval) {
      return false;
    }

    try {
      const result = await this.exportData();
      if (result.success) {
        // ä¿å­˜å¤‡ä»½
        const fileName = this.exportImport.generateExportFileName();
        await this.saveBackup(fileName, result.data);

        // æ¸…ç†æ—§å¤‡ä»½
        await this.cleanOldBackups();

        return true;
      }
      return false;
    } catch (e) {
      console.error('[DataSyncManager] Auto backup failed:', e);
      return false;
    }
  }

  /**
   * è·å–æ‰€æœ‰ç¼“å­˜çš„å®šä¹‰
   */
  private async getAllCachedDefinitions(): Promise<ExportedDefinition[]> {
    const rows = await this.dbManager.getAllDefinitions();
    return rows.map((row): ExportedDefinition => new ExportedDefinition(
      row.word,
      row.definition,
      row.source,
      row.createdAt
    ));
  }

  /**
   * å¢é‡å¯¼å‡ºæ•°æ®ï¼ˆä»…å¯¼å‡ºæŒ‡å®šæ—¶é—´åå˜æ›´çš„æ•°æ®ï¼‰
   */
  async exportIncremental(sinceMs: number, includeDefinitions: boolean = false): Promise<ExportResult> {
    try {
      const words = await this.dbManager.getLearnedWordsUpdatedAfter(sinceMs);
      console.info(`[DataSyncManager] Incremental export: ${words.length} words updated after ${sinceMs}`);

      await new Promise<void>((resolve) => setTimeout(resolve, 0));

      let definitions: ExportedDefinition[] = [];
      if (includeDefinitions) {
        definitions = await this.getAllCachedDefinitions();
      }

      await new Promise<void>((resolve) => setTimeout(resolve, 0));

      const userBooks = await this.dbManager.getUserWordBooks();
      const exportedBooks: ExportedUserBook[] = [];
      for (const book of userBooks) {
        if (book.updatedAt > sinceMs) {
          const input: ExportedUserBookInput = {
            id: book.id,
            name: book.name,
            description: book.description,
            category: book.category,
            difficulty: book.difficulty,
            coverColor: book.coverColor,
            icon: book.icon,
            createdAt: book.createdAt,
            updatedAt: book.updatedAt
          };
          exportedBooks.push(new ExportedUserBook(input));
        }
      }

      const settingsStore = SettingsStore.getInstance();
      const fsrsParams = await settingsStore.getFsrsParams();
      const fsrsParamsJson = fsrsParams !== null ? fsrsParams.toJSON() : '';
      const jsonData = await this.exportImport.exportToJSONAsync(words, definitions, this.versionControl, fsrsParamsJson, exportedBooks);

      return { success: true, data: jsonData, error: '' };
    } catch (e) {
      const errMsg = e instanceof Error ? e.message : String(e);
      console.error('[DataSyncManager] Incremental export failed:', errMsg);
      return { success: false, data: '', error: errMsg };
    }
  }

  /**
   * å¢é‡å¯¼å…¥æ•°æ®ï¼ˆåˆå¹¶ç­–ç•¥ï¼šupdatedAt æ›´æ–°çš„è¦†ç›–ï¼‰
   */
  async importIncremental(jsonData: string): Promise<SyncResult> {
    try {
      const importResult = this.exportImport.importFromJSON(jsonData, this.versionControl);
      const data: ExportData = importResult.data;
      const result: SyncResult = importResult.result;

      if (result.hasErrors()) {
        this.syncStatus = SyncStatus.ERROR;
        return result;
      }

      if (data.fsrsParamsJson.length > 0) {
        const params = FsrsParamsPack.fromJSON(data.fsrsParamsJson);
        if (params !== null) {
          const settingsStore = SettingsStore.getInstance();
          await settingsStore.saveFsrsParams(params);
          FSRSAlgorithm.getInstance().setParameters(params.w, params.requestRetention, params.maximumInterval);
        }
      }

      for (const word of data.words) {
        try {
          const wordItem = this.convertToWordItem(word);
          const existing = await this.dbManager.getWordByWord(wordItem.word);

          if (existing === null) {
            await this.dbManager.insertWord(wordItem);
            result.imported++;
          } else if (wordItem.updatedAt > existing.updatedAt) {
            wordItem.id = existing.id;
            await this.dbManager.updateWord(wordItem);
            result.updated++;
          } else {
            result.skipped++;
          }
        } catch (e) {
          const errMsg = e instanceof Error ? e.message : String(e);
          result.addError(`å¯¼å…¥å•è¯å¤±è´¥: ${errMsg}`);
        }

        if ((result.imported + result.updated + result.skipped) % 50 === 0) {
          await new Promise<void>((resolve) => setTimeout(resolve, 0));
        }
      }

      for (const def of data.definitions) {
        try {
          const wordDef = WordDefinition.fromJSON(def.definition);
          await this.dbManager.cacheDefinition(def.word, wordDef);
        } catch (e) {
          const errMsg = e instanceof Error ? e.message : String(e);
          result.addError(`å¯¼å…¥å®šä¹‰å¤±è´¥: ${errMsg}`);
        }
      }

      const existingUserBooks = await this.dbManager.getUserWordBooks();
      const userBookMap = new Map<string, UserWordBook>();
      for (const existingBook of existingUserBooks) {
        userBookMap.set(existingBook.id, existingBook);
      }

      for (const book of data.userBooks) {
        try {
          const existing = userBookMap.get(book.id);

          if (existing === undefined) {
            const newBookId = await this.dbManager.createUserWordBook(
              book.name,
              book.description,
              book.category || 'å…¶ä»–',
              book.difficulty || 'åˆçº§',
              book.coverColor || '',
              book.icon || 'ğŸ““'
            );
            const createdBook = await this.dbManager.getUserWordBookById(newBookId);
            if (createdBook !== null) {
              userBookMap.set(createdBook.id, createdBook);
            }
          } else if (book.updatedAt > existing.updatedAt) {
            await this.dbManager.updateUserWordBook({
              id: existing.id,
              name: book.name,
              description: book.description,
              wordCount: existing.wordCount,
              isUserCreated: true,
              createdAt: existing.createdAt,
              updatedAt: book.updatedAt,
              category: book.category,
              difficulty: book.difficulty,
              coverColor: book.coverColor,
              icon: book.icon
            });
            const refreshedBook = await this.dbManager.getUserWordBookById(existing.id);
            if (refreshedBook !== null) {
              userBookMap.set(refreshedBook.id, refreshedBook);
            }
          }
        } catch (e) {
          const errMsg = e instanceof Error ? e.message : String(e);
          result.addError(`å¯¼å…¥è¯ä¹¦å¤±è´¥: ${errMsg}`);
        }
      }

      return result;
    } catch (e) {
      const errMsg = e instanceof Error ? e.message : String(e);
      console.error('[DataSyncManager] Incremental import failed:', errMsg);
      const result = new SyncResult();
      result.addError(`å¯¼å…¥å¤±è´¥: ${errMsg}`);
      return result;
    }
  }

  /**
   * è½¬æ¢ä¸ºWordItem
   */
  private convertToWordItem(exportedWord: ExportedWord): WordItem {
    let definition: WordDefinition = new WordDefinition();
    if (exportedWord.definition && exportedWord.definition.length > 0 && 
        (exportedWord.definitionSource === 'ai' || exportedWord.definitionSource === 'local')) {
      try {
        definition = WordDefinition.fromJSON(exportedWord.definition);
      } catch (e) {
        console.warn(`[DataSyncManager] Failed to parse definition for ${exportedWord.word}`);
      }
    }

    return new WordItem(
      exportedWord.id,
      exportedWord.word,
      exportedWord.status as WordStatus,
      undefined,
      undefined,
      definition,
      exportedWord.dueDate,
      exportedWord.createdAt,
      exportedWord.updatedAt,
      exportedWord.bookId,
      exportedWord.tags,
      exportedWord.lapseCount ?? 0,
      exportedWord.leechLevel ?? 0,
      exportedWord.errorTags ?? [],
      exportedWord.suspendUntil ?? 0
    );
  }

  /**
   * ä¿å­˜å¤‡ä»½
   */
  private async saveBackup(fileName: string, data: string): Promise<void> {
    // è¿™é‡Œéœ€è¦å®ç°æ–‡ä»¶ä¿å­˜åŠŸèƒ½
    // æš‚æ—¶åªè®°å½•å¤‡ä»½ä¿¡æ¯
    const backupInfo = new BackupInfo(
      fileName,
      Date.now(),
      data.length,
      0 // éœ€è¦ä»æ•°æ®ä¸­è®¡ç®—
    );
    this.backups.push(backupInfo);
  }

  /**
   * è·å–æœ€åå¤‡ä»½æ—¶é—´
   */
  private getLastBackupTime(): number {
    if (this.backups.length === 0) {
      return 0;
    }
    return this.backups[this.backups.length - 1].timestamp;
  }

  /**
   * æ¸…ç†æ—§å¤‡ä»½
   */
  private async cleanOldBackups(): Promise<void> {
    while (this.backups.length > this.syncConfig.maxBackupCount) {
      const oldBackup = this.backups.shift();
      if (oldBackup !== undefined) {
        // åˆ é™¤æ—§å¤‡ä»½æ–‡ä»¶
        await this.deleteBackup(oldBackup.fileName);
      }
    }
  }

  /**
   * åˆ é™¤å¤‡ä»½
   */
  private async deleteBackup(fileName: string): Promise<void> {
    // è¿™é‡Œéœ€è¦å®ç°æ–‡ä»¶åˆ é™¤åŠŸèƒ½
    console.log(`[DataSyncManager] Deleting backup: ${fileName}`);
  }

  /**
   * è·å–å¤‡ä»½åˆ—è¡¨
   */
  getBackups(): BackupInfo[] {
    return [...this.backups];
  }

  /**
   * æ¢å¤å¤‡ä»½
   */
  async restoreBackup(fileName: string): Promise<SyncResult> {
    try {
      // è¿™é‡Œéœ€è¦å®ç°ä»æ–‡ä»¶è¯»å–æ•°æ®çš„åŠŸèƒ½
      // æš‚æ—¶è¿”å›ç©ºç»“æœ
      return new SyncResult();
    } catch (e) {
      const errMsg = e instanceof Error ? e.message : String(e);
      const result = new SyncResult();
      result.addError(`æ¢å¤å¤‡ä»½å¤±è´¥: ${errMsg}`);
      return result;
    }
  }

  /**
   * åˆå¹¶æ•°æ®ï¼ˆç”¨äºè§£å†³å†²çªï¼‰
   */
  async mergeData(otherData: ExportData): Promise<SyncResult> {
    const result = new SyncResult();

    try {
      // æ¯”è¾ƒç‰ˆæœ¬
      const otherVersionControl = VersionControl.fromJSON(otherData.versionControl);
      const comparison = VersionControl.compareVersions(
        this.versionControl.getCurrentVersion(),
        otherVersionControl.getCurrentVersion()
      );

      if (comparison === 0) {
        // ç‰ˆæœ¬ç›¸åŒï¼Œæ£€æŸ¥æ—¶é—´æˆ³
        const resolved = this.versionControl.resolveConflict(
          otherVersionControl.getCurrentVersion()
        );

        if (resolved === this.versionControl.getCurrentVersion()) {
          result.addError('å½“å‰æ•°æ®è¾ƒæ–°ï¼Œæ— éœ€åˆå¹¶');
          return result;
        }
      }

      // åˆå¹¶å•è¯æ•°æ®
      for (const word of otherData.words) {
        try {
          const existing = await this.dbManager.getWordByWord(word.word);
          if (existing === null) {
            // æ–°å•è¯ï¼Œç›´æ¥æ·»åŠ 
            const wordItem = this.convertToWordItem(word);
            await this.dbManager.insertWord(wordItem);
            result.imported++;
          } else {
            // å·²å­˜åœ¨ï¼Œæ¯”è¾ƒæ—¶é—´æˆ³
            if (word.updatedAt > existing.updatedAt) {
              // å¯¼å…¥çš„æ•°æ®æ›´æ–°
              const wordItem = this.convertToWordItem(word);
              wordItem.id = existing.id;
              await this.dbManager.updateWord(wordItem);
              result.updated++;
            } else {
              // å½“å‰æ•°æ®æ›´æ–°ï¼Œè·³è¿‡
              result.skipped++;
            }
          }
        } catch (e) {
          const errMsg = e instanceof Error ? e.message : String(e);
          result.addError(`åˆå¹¶å•è¯å¤±è´¥: ${errMsg}`);
        }
      }

      // æ›´æ–°ç‰ˆæœ¬æ§åˆ¶
      this.versionControl = otherVersionControl;

      return result;
    } catch (e) {
      const errMsg = e instanceof Error ? e.message : String(e);
      result.addError(`åˆå¹¶æ•°æ®å¤±è´¥: ${errMsg}`);
      return result;
    }
  }

  /**
   * é‡ç½®åŒæ­¥çŠ¶æ€
   */
  resetSyncStatus(): void {
    this.syncStatus = SyncStatus.IDLE;
  }

  /**
   * è·å–åŒæ­¥ç»Ÿè®¡
   */
  getSyncStats(): SyncStats {
    const stats: SyncStats = {
      totalBackups: this.backups.length,
      totalChanges: this.versionControl.getChangeLog().length,
      lastSyncTime: this.versionControl.getCurrentVersion().timestamp
    };
    return stats;
  }
}

export interface ExportResult {
  success: boolean;
  data: string;
  error: string;
}

export interface SyncStats {
  totalBackups: number;
  totalChanges: number;
  lastSyncTime: number;
}
